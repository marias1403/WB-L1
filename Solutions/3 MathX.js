const MathX = (function() {
  // Метод для вычисления N-го числа в ряду Фибоначчи.
  // Про оптимизацию:
  // Time complexity: O(N) — время выполнения алгоритма пропорционально числу N, где N - номер Фибоначчи.
  // Space complexity: O(1) — количество используемой памяти не зависит от числа N
  function fibonacci(n) {
    if (n <= 1) {
      return n;
    }
    // Нам нужно три переменных: current — это fib(N), текущее значение
    // prev1 — это fib(N-1), при инициализации равно 1, второе число из чисел Фибоначчи
    // prev2 — это fib(N-2), при инициализации равно 0, первое число
    let current = 0;
    let prev1 = 1;
    let prev2 = 0;
    // Начинаем с i = 2, потому что первые два числа мы уже инициализировали
    // Цикл идет до числа n включительно
    for (let i = 2; i < n; i++) {
      // Высчитываем текущее число Фибоначчи, которое равно сумме двух предыдущих
      current = prev1 + prev2;
      // Теперь значение prev2 равно значению prev1.
      // prev1 равно current, это нужно для вычисления числа Фибоначчи в следующей итерации
      prev2 = prev1;
      prev1 = current;
      // продолжаем цикл в i++
    }
    // по окончании цикла возвращаем результат
    return current;
  }
  // Метод для вычисления всех чисел в ряду Фибоначчи до числа N
  // Про оптимизацию:
  // Time complexity: O(N) — Цикл for имеет линейную временную сложность O(n).
  // Space complexity: O(N) — пространственная сложность зависит от размера входного числа n
  function fibonacciSeries(n) {
    // Инициализируем массив чисел Фибоначчи с двумя первыми значениями
    let series = [0, 1];
    // Добавляем в конец массива значение числа Фибоначчи
    // Цикл ведем до числа n, вычисляя необходимое количество чисел Фибоначчи
    for (let i = 2; i < n; i++) {
      series.push(series[i - 1] + series[i - 2]);
    }
    // Добавляем массив
    return series;
  }
  // Метод для вычисления N-го простого числа
  // Time complexity: O(n * sqrt(num)) — функция isPrime имеет сложность O(sqrt(num)) и функция prime — O(n * sqrt(num))
  // Space complexity: O(1) — код использует несколько переменных
  // Функция, которая получает число и возвращает, является ли оно простым или нет
  function isPrime(n) {
    if (n <= 1) {
      return false;
    }
    // Итерируемся до квадратного корня числа, этого достаточно, чтобы найти делители
    // Если остаток деления на i равно 0, то это не просто число
    for (let i = 2; i <= Math.sqrt(n); i++) {
      if (n % i === 0) {
        return false;
      }
    }
    return true;
  }
  // Основная функция для нахождения N-го простого числа
  // Переменная count для подсчета количества простых чисел
  // Переменная num — это первое простое число
  function prime(n) {
    let count = 0;
    let num = 2;
    // Используем loop, пока count меньше n
    // Если число простое, увеличиваем count на 1
    // При каждой итерации увеличиваем num на 1
    while (count < n) {
      if (isPrime(num)) {
        count++;
      }
      num++;
    }
    return num - 1;
  }
  // Метод для вычисления всех простых чисел до числа N
  // Для нахождения простых чисел можно использовать решето Эрастофена — алгоритм нахождения всех простых чисел от 1 до N.
  // Мы вычеркиваем числа, делящиеся на 2, кроме самого числа, то же самое с числом 3, 5 и тд
  // Про оптимизацию:
  // Time complexity: O(loglogn) — такова эффективность алгоритма решето Эрастофена
  // Space complexity: O(N) — мы используем массив длиной n+1
  function primeSeries(n) {
    // Инициализируем массив для решета, состоящее из true длиной n + 1
    let isPrime = new Array(n + 1).fill(true);
    // 0 и 1 не являются простыми, поэтому у них значения false
    isPrime[0] = isPrime[1] = false;
    // Запускаем цикл, который итерируется с 2 до квадратного корня из n,
    // потому что делитель N в любом случае меньше sqrt(n)
    for (let i = 2; i * i <= n; i++) {
    // Если i простое число, запускаем другой цикл
      if (isPrime[i]) {
        // Начинаем с i * i, потому что все числа меньше i * i
        // уже были отмечены как непростые на предыдущих итерациях внутреннего цикла.
        // При каждой итерации увеличиваем j на i, потому что нам нужно стереть все числа кратные i
        for (let j = i * i; j <= n; j += i) {
          // Отмечаем непростые числа как false
          isPrime[j] = false;
        }
      }
    }
    // Создаем массив для вывода простых чисел
    let primes = [];
    // Запускаем цикл с 2, потому что мы знаем, что 0 и 1 уже false
    for (let i = 2; i <= n; i++) {
      // В массив primes добавляем все простые числа со значением true
      if (isPrime[i]) {
        primes.push(i);
      }
    }
    // Возвращаем итоговый массив
    return primes;
  }

  return {
    fibonacci: fibonacci,
    fibonacciSeries: fibonacciSeries,
    prime: prime,
    primeSeries: primeSeries
  };
})();

console.log(MathX.fibonacci(10)); // Вычисление 10-го числа Фибоначчи
console.log(MathX.fibonacciSeries(10)); // Вычисление всех чисел Фибоначчи до 10
console.log(MathX.prime(5)); // Вычисление 5-го простого числа
console.log(MathX.primeSeries(20)); // Вычисление всех простых чисел до 20
